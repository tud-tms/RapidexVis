<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COSMO Rapidex-Vis</title>
    <!-- Include Mapbox CSS -->
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.0-rc.1/mapbox-gl.css' rel='stylesheet' />
    <link href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css' rel='stylesheet' />
    <!-- Include your custom CSS styles here -->
    <style>
body {
    background-color: #f1f1f1;
    font-family: 'San Francisco', Arial, sans-serif;
    font-weight: 400; /* This sets the font weight to Regular. Change this value to use other weights */
}

/* Container for the map and the overlays */
.map-container {
    position: absolute;
    bottom: 50px;
    left: 10px;
    z-index: 1000;
    display: flex;
    align-items: center;
    margin-right: 50px;
}

/* Styles for the map itself */
.map {
  height: 99%;
  width: 99%;
}

.radiobox-container{
    position: fixed;
    display: flex;
    gap: 40px;
    border-radius: 8px;
    padding: 5px;
    pointer-events: auto;
    border-radius: 8px;
    border-color: 2px solid #4CAF50;
    bottom: 80px !important;
    background-color: rgba(255, 255, 255, 0.5);
}
.roads {
  position: fixed;
  gap: 10px;
  border-radius: 8px;
  padding: 5px;
  pointer-events: auto;
  display: flex;
  right: 80px;
  bottom: 80px;
  border-radius: 8px;
  border-color: 2px solid #4CAF50;
  background-color: rgba(255, 255, 255, 0.5);
  flex-direction: column;
  align-items: flex-start;
}
        .road-container-row {
            display: flex; /* Align road containers in a row */
            flex-wrap: wrap; /* Wrap them to next line if space is not sufficient */
            margin-top: 5px; /* Spacing between label and road container row */
        }
        .road-container {
            text-align: center; /* Center-align the image and name */
            margin-right: 10px; /* Spacing between road containers */
        }

    .road-img {
        width: 50px;
        margin-right: 10px;
        cursor: pointer;
        transition: transform 0.3s ease;
        opacity: 1;
        margin-bottom: 4px;
    }
   .road-name {
            display: block;
            color: black;
            margin: 0; 
            white-space: pre-line;
    }
    .selected {
        position: relative;
        opacity: 0.5;
        transform: scale(0.8); 
    }

    .selected {
        opacity: 0.5;
        transform: scale(0.8);
    }


    .selected-text {
        color: red;
        font-weight: bold;
    }

    .button-container button {
        border: none; 
        background: none; 
        padding: 0; 
        cursor: pointer;
    }
    .button-img { 
        width: 100px; 
        height: auto; 
        transition: transform 0.3s ease; 
    }
    .normal { 
        opacity: 0.5;
    }
    .highlighted { 
        opacity: 1;
        transform: scale(1.2); 
    }


.mapboxgl-ctrl-bottom-right {
    bottom: 50px !important;
}

.mapboxgl-ctrl-rotate {
    background-image: url('src/images/rotate.svg');
    background-size: 20px 20px;
    background-position: center;
    background-repeat: no-repeat;
    width: 32px;
    height: 32px;
}
.mapboxgl-ctrl-map {
    background-image: url('src/images/map.svg');
    background-size: 20px 20px;
    background-position: center;
    background-repeat: no-repeat;
    width: 32px;
    height: 32px;
}
.mapboxgl-ctrl-3d {
    background-image: url('src/images/3d.svg');
    background-size: 20px 20px;
    background-position: center;
    background-repeat: no-repeat;
    width: 32px;
    height: 32px;
}

#folderSlider {
    width: 100%;
    height: 20px; /* match the height of the SVG's rounded rectangle */
    border-radius: 4px;
    background: linear-gradient(to right, #ccc 0%, #ccc 100%);
    opacity: 0.8;
    appearance: none;  /* removes default styling */
    outline: none;
    transition: background 0.2s;
}

#folderSlider::-webkit-slider-thumb {
    width: 100px;
    height: 40px;  /* match the height of the SVG's rounded rectangle */
    background-image: url('src/images/slider.svg'); 
    background-size: cover;
    background-position: center;  /* vertically center the SVG within the thumb */
    cursor: grab;
    color: transparent;
    appearance: none;  /* removes default styling */
}

#folderSlider::-moz-range-thumb {
    width: 100px;
    height: 40px;  /* match the height of the SVG's rounded rectangle */
    background-image: url('src/images/slider.svg'); 
    color: transparent;
    background-size: cover;
    background-position: center;  /* vertically center the SVG within the thumb */
    cursor: grab;
}

    #folderName {
        display: none;
        position: absolute;
        top: -38px;
        left: 0;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        white-space: nowrap;
    }

    .mapboxgl-popup {
        /* This ensures the popup width is enough to prevent wrapping for typical content */
        min-width: 200px; 
    }

    .mapboxgl-popup-content {
        padding: 12px 15px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .mapboxgl-popup-close-button {
        position: absolute;
        right: 10px;
        top: 10px;
        width: 16px;
        height: 16px;
    }
    .edge-popup {
        width: 250px;
    }
    .edge-popup h3, .zone-popup h3 {
        margin-top: 0;
        color: #333;
        font-size: 15px;
        margin-bottom: 6px;
        padding-bottom: 3px;
        border-bottom: 1px solid #eee;
    }

    .edge-popup p, .zone-popup p {
        color: #555;
        margin: 4px 0;
        font-size: 14px;
        line-height: 1.4;
        display: flex;
    }

    .edge-popup p span {
        white-space: normal;
        display: inline-block;
        vertical-align: top;
    }
    #other-direction-btn {
        padding: 4px 10px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    .edge-popup .coordinate {
        margin-right: 4px;
        font-weight: bold;
        display: inline-block;
        min-width: 140px;
    }
    .zone-popup {
        width: 200px;
    }

    .zone-popup strong {
        font-weight: bold;
        margin-right: 4px;
    }
    .volume-tt {
        color: #4CAF50;
        font-weight: bold;
    }
    .co2 {
        color: #f44336;
        font-weight: bold;
    }
    #edge-options-container {
        display: none;
        position: absolute;
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        font-family: Arial, sans-serif;
    }
    #edge-options-container label {
        display: block;
        margin-bottom: 8px;
    }
    #edge-options-container input, #edge-options-container select {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    #edge-options-container button {
        padding: 8px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    #edge-options-container button:hover {
        background-color: #0056b3;
    }

    .form-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 95%;
    }

    .form-column {
        display: flex;
        flex-direction: column;
        margin-bottom: 10px;
        width: 45%;
    }

    .form-column input[type="text"],
    .form-column input[type="number"],
    .form-column select {
        width: 100%;
    }

    .small-input {
        width: 10%;
    }

    .radio-group {
        display: flex;
        align-items: center;
    }

    .radio-label {
        margin-right: 10px;
    }

    .popup {
    display: none;
    position: absolute;
    width: 350px;
    height: 300px;
    bottom: 110%; /* Position above the button */
    transform: translateX(0%);
    border: 2px solid #4CAF50;
    border-radius: 8px;
    background-color: #fff;
    padding: 10px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 10;
}

.popup-heading {
    font-weight: bold;
    margin: 0;
    padding: 0;
    text-align: center;
}

.popup-text {
    margin: 10px 0 0; /* Adds some space above the text */
    color: #333;
    text-align: justify;
    font-size: large;
}

.close-btn {
    position: absolute;
    top: 0;
    right: 10px;
    cursor: pointer;
    font-size: 20px;
}
.chair {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 200px;
    height: auto;
    z-index: 1000;
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 8px;
}
.nvidia {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 100px;
    height: auto;
    z-index: 1000;
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 2px;
}

@media screen and (max-width: 768px) {
    .roads, .radiobox-container {
        flex-direction: row; /* Change to row for mobile */
        align-items: center; /* Center align items for a cleaner look */
    }
    .road-img, .button-img .chair, .nvidia{
        width: 10%; /* Reduce image size to 50% of its current size on mobile devices */
    }

}
 </style>
<link rel="icon" href="src/images/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="src/images/favicon.ico" type="image/x-icon">
</head>
<body>
    <img src="src/images/chair.png" alt="TMS" class="chair">
    <img src="src/images/nvidia.png" alt="Nvidia" class="nvidia">
    <div id="map" style="width: 99vw; height: 98.5vh;"></div>
    <div class="map-container">
        <div class="radiobox-container" id="checkbox-dataDropdown">
            <div class="button-container">
                <button onclick="selectVisualization('congestion')">
                    <img id="congestionImg" class="button-img highlighted" src="src/images/congestion.png" alt="Congestion">
                    <div class="popup" id="congestionPopup">
                        <h1 class="popup-heading">Stau</h1>
                        <p class="popup-text">Die Karte veranschaulicht die Überlastung des Netzes anhand eines Farbverlaufs, der linear von grün über orange nach rot verläuft, wobei jede Verbindung farblich gekennzeichnet ist, um den Grad der Überlastung darzustellen.<br><br> Diese Links sind interaktiv; wenn Sie auf einen Link klicken, werden Informationen zum Verkehrsfluss, zur Kapazität, zur Reisezeit und zur Reisezeit im freien Verkehr angezeigt.</p>
                        <span class="close-btn" onclick="closePopup(event, 'congestionPopup')">&times;</span>
                    </div>
                </button>
            </div>
            <div class="button-container">
                <button onclick="selectVisualization('emission')">
                    <img id="emissionImg" class="button-img normal" src="src/images/emissions.png" alt="Zonal Emissions">
                    <div class="popup" id="emissionPopup">
                        <h1 class="popup-heading">Emissionen</h1>
                        <p class="popup-text">Die angezeigte Karte kategorisiert die zonalen Emissionen anhand eines linearen Farbverlaufs, der von grün über orange bis rot reicht. <br><br> Die Zonen auf der Karte sind interaktiv. Wenn Sie eine Zone auswählen, erscheint ein Pop-up-Fenster mit Informationen über die zonalen Emissionen und ihre Fläche.</p>
                        <span class="close-btn" onclick="closePopup(event, 'emissionPopup')">&times;</span>
                    </div>
                </button>
            </div>
            <div class="button-container">
                <button onclick="selectVisualization('equity')">
                    <img id="equityImg" class="button-img normal" src="src/images/equity.png" alt="Zonal Equity">
                    <div class="popup" id="equityPopup">
                        <h1 class="popup-heading">Gerechtigkeit</h1>
                        <p class="popup-text">Die Karte zeigt die zonale Gerechtigkeit für alle Verkehrsteilnehmer mit einem linearen Farbverlauf von rot zu orange und schließlich zu grün. <br><br> Die Zonen auf der Karte sind interaktiv. Wenn Sie eine Zone auswählen, erscheint ein Popup-Fenster, das Informationen über die zonale Gerechtigkeit und ihr Gebiet enthält.</p>
                        <span class="close-btn" onclick="closePopup(event, 'equityPopup')">&times;</span>
                    </div>
                </button>
            </div>
        </div>
        <div class="roads" id="road-selection">
            <label><strong>Zu schließende Straße(n) auswählen</strong></label>
            <div class="road-container-row">
            <div class="road-container">
                <img src="src/images/bridge.png" alt="Carola Bridge" class="road-img" onclick="toggleSelection(this, '1')">
                <span class="road-name">Carolabrücke</span>
            </div>
            <div class="road-container">
                <img src="src/images/road.png" alt="Königsbrücker Straße" class="road-img" onclick="toggleSelection(this, '3')">
                <span class="road-name">Königsbrücker<br>Straße</span>
            </div>
            <div class="road-container">
                <img src="src/images/street.png" alt="Zellescher Weg" class="road-img" onclick="toggleSelection(this, '2')">
                <span class="road-name">Zellescher<br> Weg</span>
            </div>
            <div class="road-container">
                <img src="src/images/highway.png" alt="Road 4" class="road-img" onclick="toggleSelection(this, '4')">
                <span class="road-name">Bautzner<br>Straße</span>
            </div>
            </div>
        </div>
    </div>
    <div id="folderSliderContainer" style="position: fixed; bottom: 10px; left: 1vw; z-index: 1000; width: 98vw;">
        <div id="folderName"></div>
        <input type="range" min="0" max="0" value="0" class="slider" id="folderSlider">
    </div>
    </div>
    </div>

    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.0-rc.1/mapbox-gl.js'></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf"></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js'></script>
<script>
        let edgesLayerId = null;
        let gridPolygonLayerId = null;
        let basepath = 'src/Dresden';
        let folder = 'base';
        let dataType = 'congestion';
        let directories = null;
        let bounds = null;
        let breaks = null;
        let currentPopup = null;
        let layerCounter = 0;
        let slider = document.getElementById('folderSlider');
        let popupTimer;
        let selectedRoads = {};

            // Initialize Mapbox
        mapboxgl.accessToken = 'pk.eyJ1Ijoic3VyZW5kcmEyOSIsImEiOiJjbHNscmRxZmYwNTcxMmxwanVuYzNteng1In0.g9dXqJHcxAwf2eKk0uyCTg';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/standard',
            center: [13.728688, 51.030713],
            zoom: 17,
            pitch: 60,
            bearing: 37.6,
            projection: 'globe' // set the projection to globe
        });

        map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
        // Create a new mapboxgl button control Top Down View and fit to map bounds
        class TopDown {
        onAdd(map) {
            this.map = map;
            this.container = document.createElement('div');
            this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
            const button = document.createElement('button');
            button.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-map';
            button.type = 'button';
            button.title = 'Top Down';
            button.onclick = () => {
                map.flyTo({
                        pitch: 0,
                        bearing: 0,
                    });
                map.once('moveend', () => {
                    map.fitBounds(bounds, {padding: 20});
                });
            };
            this.container.appendChild(button);
            return this.container;
        }

        onRemove() {
            this.container.parentNode.removeChild(this.container);
            this.map = undefined;
        }
    }


        // Add the home button control to the map
        map.addControl(new TopDown(), 'bottom-right');

        // Create a new mapboxgl button control for 3D buildings
        class ThreeD {
            onAdd(map) {
                this.map = map;
                this.container = document.createElement('div');
                this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
                const button = document.createElement('button');
                button.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-3d';
                button.type = 'button';
                button.title = '3D View';
                button.onclick = () => {
                    map.flyTo({
                        zoom: 16,
                        pitch: 65,
                        bearing: 0,
                    });
                };
                this.container.appendChild(button);
                return this.container;
            }
        
            onRemove() {
                this.container.parentNode.removeChild(this.container);
                this.map = undefined;
            }
        }

        // Add the home button control to the map
        map.addControl(new ThreeD(), 'bottom-right');

        // Create a new mapboxgl button control for continuous rotation
        class RotateControl {
            onAdd(map) {
                this.map = map;
                this.container = document.createElement('div');
                this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
                const button = document.createElement('button');
                button.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-rotate';
                button.type = 'button';
                button.title = 'Rotate';
                button.onclick = () => {
                    this._rotateMap();
                };
                this.container.appendChild(button);
                return this.container;
            }

            _rotateMap() {
                const rotate = () => {
                    this.map.setBearing(this.map.getBearing() + 0.25);
                    this.animationFrame = requestAnimationFrame(rotate);
                };
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                } else {
                    this.animationFrame = requestAnimationFrame(rotate);
                }
            }

            onRemove() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                this.container.parentNode.removeChild(this.container);
                this.map = undefined;
            }
        }

        // Add the rotate button control to the map
        map.addControl(new RotateControl(), 'bottom-right');

        updateFolder();
        updateVisualization();
        map.on('load', function() {
            window.setTimeout(() => selectVisualization('congestion'), 0);
        });
        function selectVisualization(visualization) {
            closeCurrentPopup();

            document.querySelectorAll('.button-img').forEach(img => {
                img.classList.remove('highlighted');
                img.classList.add('normal');
            });

            const imgId = visualization + 'Img';
            const popupId = visualization + 'Popup';
            const selectedImg = document.getElementById(imgId);
            if (selectedImg) {
                selectedImg.classList.remove('normal');
                selectedImg.classList.add('highlighted');
                const popup = document.getElementById(popupId);
                popup.style.display = 'block';
                popupTimer = setTimeout(() => {
                    popup.style.display = 'none';
                }, 5000);
            }

            // Update dataType only if a different visualization is selected
            if (dataType !== visualization) {
                dataType = visualization;
            }
            updateVisualization();
        }

        function closePopup(event, popupId) {
            event.stopPropagation();

            const popup = document.getElementById(popupId);
            popup.style.display = 'none';

            clearTimeout(popupTimer);
        }


        function closeCurrentPopup() {
            const openPopup = document.querySelector('.popup[style*="display: block"]');
            if (openPopup) {
                openPopup.style.display = 'none';
            }
            clearTimeout(popupTimer);
        }

        function toggleSelection(image, roadId) {
            image.classList.toggle('selected');
            const roadNameSpan = image.nextElementSibling;
            roadNameSpan.classList.toggle('selected-text');

            if (selectedRoads[roadId]) {
                delete selectedRoads[roadId];
            } else {
                selectedRoads[roadId] = true;
            }

            updateFolder();
            updateVisualization();
        }
        
        function updateFolder() {
            if (Object.keys(selectedRoads).length === 0) {
                folder = 'base';
            } else {
                folder = Object.keys(selectedRoads).join('_');
            }
            drawGeoJSONLayers(folder);
        }

        function readdirectories(idx) {
            return fetch(`${basepath}/${folder}/models/assignments/directories.json`)
                .then(response => response.json())
                .then(data => {
                    directories = data;
                    slider = document.getElementById('folderSlider');
                    slider.max = directories.length - 1;
                    if (idx === null) {
                        slider.value = Math.floor(directories.length / 2);
                    }
                    else {
                        slider.value = idx;
                    }
                    updateSliderBackgroundandOffset(slider, bubble)
                    document.getElementById('folderName').textContent = directories[slider.value].name;
                })
                .catch(error => console.error('Error fetching directories:', error));
        }

        function updateVisPathAndVisualize(index) {
            const sfolder = directories[index].name;
            colorCode(dataType, folder, sfolder);
        }

        async function updateVisualization() {
            const idx = Number(slider.value);
            await readdirectories(idx); // Wait for directories to be fetched and processed
            updateVisPathAndVisualize(idx);
        }

    dataType = document.querySelector('.highlighted').alt;

    function drawGeoJSONLayers(folderPath) {
        // Remove existing layers
        if (edgesLayerId && map.getLayer(edgesLayerId)) {
            map.removeLayer(edgesLayerId);
            map.removeSource('edges-source');
        }
        if (gridPolygonLayerId && map.getLayer(gridPolygonLayerId + '-border')) {
            map.removeLayer(gridPolygonLayerId + '-border');
        }
        if (gridPolygonLayerId && map.getLayer(gridPolygonLayerId)) {
            map.removeLayer(gridPolygonLayerId);
            map.removeSource('grid-polygon-source');
        }
        // Get the colors based on the current style
        let edgeColor = '#8B008B';
        let zoneColor = '#4169E1';
        let zoneBorderColor = '#00008B';

        fetch(`${basepath}/${folderPath}/edges.geojson`)
            .then(response => response.json())
            .then(data => {
                edgesGeojsonData = data;
                map.on('load', function() {
                    map.addSource('edges-source', {
                        type: 'geojson',
                        data: edgesGeojsonData
                    });
                });
                edgesLayerId = 'edges-layer-' + new Date().getTime();
                map.on('load', function() {
                    map.addLayer({
                        id: edgesLayerId,
                        type: 'line',
                        source: 'edges-source',
                        paint: {
                            'line-color': edgeColor,
                            'line-width': [
                                        'interpolate', 
                                        ['linear'], 
                                        ['zoom'],
                                        // Zoom level and corresponding line width
                                        1, 1,  // At zoom level 1, line width will be 1
                                        5, 2,  // At zoom level 5, line width will be 2
                                        10, 3,  // At zoom level 10, line width will be 3
                                        15, 5,  // At zoom level 15, line width will be 4
                                        18, 10, // At zoom level 18, line width will be 10
                                        20, 15, // At zoom level 20, line width will be 15
                                    ],
                        },
                    });
                });
            })
            .catch(error => console.error('Error fetching GeoJSON:', error));

        // Add grid_polygon.geojson layer
        map.on('load', function() {
            map.addSource('grid-polygon-source', {
                type: 'geojson',
                data: `${basepath}/${folder}/zones.geojson`,
            });
        });
        
        // Generate a unique layer ID using the counter
        gridPolygonLayerId = `grid-polygon-layer-${layerCounter}`;
        layerCounter++;
        map.on('load', function() {
            // Add the grid polygon layer outside of the event handler
            map.addLayer({
                id: gridPolygonLayerId,
                type: 'fill',
                source: 'grid-polygon-source',
                paint: {
                    'fill-color': zoneColor,
                    'fill-opacity': 0.2, // You can adjust the opacity as needed
                },
            });
            map.addLayer({
                id: gridPolygonLayerId + '-border',
                type: 'line',
                source: 'grid-polygon-source',
                layout: {},
                paint: {
                    'line-color': zoneBorderColor,
                    'line-width': 3 // Adjust this value for your desired thickness
                }
            }, gridPolygonLayerId); // This ensures the line layer is below the fill layer
        });
        // Fetch GeoJSON data to calculate bounds
        fetch(`${basepath}/${folderPath}/zones.geojson`)
            .then(response => response.json())
            .then(geojsonData => {
                // Extract coordinates from the GeoJSON data
                const coordinates = [];
                geojsonData.features.forEach(feature => {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates.forEach(polygon => {
                            polygon.forEach(coord => {
                                coordinates.push(coord);
                            });
                        });
                    }
                });
                // Calculate bounds from the coordinates
                bounds = coordinates.reduce(function (bounds, coord) {
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

                // Fit the map to the calculated bounds
                map.on('load', function() {
                    map.fitBounds(bounds, { padding: 20 }); // You can adjust the padding as needed
                });
            });
    }
        function updateSliderBackgroundandOffset(slider, bubble) {
            const position = slider.value / slider.max;
            const offset = (slider.offsetWidth - bubble.offsetWidth) * position;
            bubble.style.left = `${offset}px`;
            const currentValuePercentage = position * 100;
            slider.style.background = `linear-gradient(to right, #4CAF50 ${currentValuePercentage}%, #ccc ${currentValuePercentage}%)`;
        }

        let bubble = document.getElementById('folderName');

        slider.addEventListener('input', function() {
            let currentIndex = Number(slider.value);
            bubble.textContent = directories[currentIndex].name;
            updateVisPathAndVisualize(currentIndex);
        });

        slider.oninput = function() {
            updateSliderBackgroundandOffset(slider, bubble);
        }

        slider.onmousedown = function() {
            bubble.textContent = directories[Number(slider.value)].name;
            bubble.style.display = 'block';
        }

        slider.onmouseup = function() {
            bubble.style.display = 'none';
        }

    async function colorCode(dataType, folderPath, foldername) {
        switch (dataType) {
            case 'congestion':
                await updateEdgesLayer(folderPath, foldername, 'congestion');
                removeBaseLayer();
                break;
            case 'emission':
                if (breaks === null) {
                    breaks = [1, 2, 4]
                }
                await updateZonesLayer(folderPath, foldername, 'emission');
                removeBaseLayer();
                break;
            case 'equity':
                if (breaks === null) {
                    breaks = [1, 3, 5]
                }
                await updateZonesLayer(folderPath, foldername, 'equity');
                removeBaseLayer();
                break;
            default:
                break;
        }
    }

    function toFixedSafe(value, digits) {
                        const number = parseFloat(value);
                        return !isNaN(number) ? number.toFixed(digits) : value;
                    }
    async function updateZonesLayer(folderPath, foldername, dataType) {
        const geojsonData = await loadAndProcessData(folderPath, foldername, dataType);
        // define color stops as an expression
        let colorStops = null;
        colorStops = [
                { value: breaks[0], color: 'green' },
                { value: breaks[1], color: 'orange' },
                { value: breaks[2], color: 'red' }
            ];
        // if (dataType === 'emissions') {
        //     colorStops = [
        //         { value: breaks[0], color: 'green' },
        //         { value: breaks[1], color: 'orange' },
        //         { value: breaks[2], color: 'red' }
        //     ];
        // }
        // else if (dataType === 'equity') {
        //     colorStops = [
        //         { value: breaks[0], color: 'red' },
        //         { value: breaks[1], color: 'orange' },
        //         { value: breaks[2], color: 'green' }
        //     ];
        // }
        // define color stops as an expression
        const colorStopsExpression = colorStops.flatMap(stop => [stop.value, stop.color]);

        if (currentPopup) {
            currentPopup.remove();
            currentPopup = null;
        }
        // Ensure edges-layer is invisible when displaying zones
        if (map.getLayer('edges-layer')) {
            map.setLayoutProperty('edges-layer', 'visibility', 'none');
        }
        if (map.getLayer('zones-layer')) {
            map.getSource('zones-layer').setData(geojsonData);
            map.setLayoutProperty('zones-layer', 'visibility', 'visible');
        }
        else{
            map.addLayer({
                id: 'zones-layer',
                type: 'fill',
                source: {
                    type: 'geojson',
                    data: geojsonData,
                },
                paint: {
                    'fill-color': [
                        'case',
                        ['boolean', ['feature-state', 'hover'], false],
                        'blue',
                        // Use Mapbox GL JS expressions to define the color scale
                        ['interpolate', ['linear'], ['get', 'value'], ...colorStopsExpression],
                    ],
                    'fill-opacity': 0.4, // You can adjust the opacity as needed
                },
            });
        }

        map.on('click', 'zones-layer', function (e) {
            if (e.features.length > 0) {
                const feature = e.features[0];
                let zoneId = feature.properties.fishnetid || feature.properties.fishnetID;
                let value = null;
                let popupContent = null;
                let area = feature.properties.area;
                if (feature.properties.zoneout === 'emission') {
                    value = toFixedSafe(feature.properties.value, 3);
                    popupContent = `
                    <div class="zone-popup">
                        <h3>Zone Details</h3>
                        <p><strong>Zone ID:</strong>&nbsp;&nbsp; ${zoneId}</p>
                        <p><strong>Area:</strong>&nbsp;&nbsp; ${area} km<sup>2</sup></p>
                        <p><strong>Value:</strong> <span class="co2">&nbsp;&nbsp;${value} Tons CO<sub>2</sub>/km<sup>2</sup> </span></p>
                    </div>
                `;
                }
                else if (feature.properties.zoneout === 'equity') {
                    value = toFixedSafe(feature.properties.value, 3); 
                    popupContent = `
                    <div class="zone-popup">
                        <h3>Zone Details</h3>
                        <p><strong>Zone ID:</strong>&nbsp;&nbsp; ${zoneId}</p>
                        <p><strong>Area:</strong>&nbsp;&nbsp; ${area} km<sup>2</sup></p>
                        <p><strong>Equity:</strong> <span class="co2">&nbsp;&nbsp;${value}</span></p>
                    </div>
                `;
                }

                if (currentPopup) {
                    currentPopup.remove();
                }

                currentPopup = new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(popupContent)
                    .addTo(map);
            }
        });
        map.on('mouseenter', 'zones-layer', function () {
            map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'zones-layer', function () {
            map.getCanvas().style.cursor = '';
        });
    }
    function calculateArea(geometry) {
        // Check if the geometry type is 'Polygon' or 'MultiPolygon'
        if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
            try {
                // Calculate the area using turf.area() which returns the area in square meters
                const area = turf.area(geometry);
                return area/1000000; // Return the area in square kilometers
            } catch (error) {
                console.error('Error calculating area:', error);
                return 0; // Return 0 if there was an error during calculation
            }
        } else {
            console.error('Invalid geometry type for area calculation.');
            return 0; // Return 0 if the geometry type is not suitable for area calculation
        }
    }
    async function updateEdgesLayer(folderPath, foldername, dataType) {
        const geojsonData = await loadAndProcessData(folderPath, foldername, dataType);
        // define color stops as an expression
        const colorStops = [
                    { value: 0.5, color: 'green' },
                    { value: 0.75, color: 'orange' },
                    { value: 10, color: 'red' }
                    ];

        const colorStopsExpression = colorStops.flatMap(stop => [stop.value, stop.color]);
        if (currentPopup) {
            currentPopup.remove();
            currentPopup = null;
        }
        // Ensure zones-layer is invisible when displaying edges
        if (map.getLayer('zones-layer')) {
            map.setLayoutProperty('zones-layer', 'visibility', 'none');
        }
        if (map.getLayer('edges-layer')) {
            map.getSource('edges-layer').setData(geojsonData);
            map.setLayoutProperty('edges-layer', 'visibility', 'visible');
        }
        else{
            map.addLayer({
                id: 'edges-layer',
                type: 'line',
                source: {
                    type: 'geojson',
                    data: geojsonData,
                },
                paint: {
                    'line-color': [
                        'case',
                        ['boolean', ['feature-state', 'hover'], false],
                        'red',
                        ['interpolate', ['linear'], ['get', 'value'], ...colorStopsExpression],
                    ],
                    'line-width': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        1, 1,
                        5, 2,
                        10, 3,
                        15, 5,
                        18, 10,
                        20, 15,
                    ],
                },
            });
        }
        function getReverseEdgeData(efrom, eto, e) {
            for (let feature of e.features) {
                const edgeFrom = feature.properties.from;
                const edgeTo = feature.properties.to;
                if (edgeFrom === eto && edgeTo === efrom) {
                    return feature.properties;
                }
            }
            return null;
        }
        function createPopupContent(edgeData) {
            const from = edgeData.from;
            const to = edgeData.to;
            const highway = edgeData.highway;
            const volume = toFixedSafe(edgeData.volume, 0);
            const capacity = edgeData.capacity;
            const length = toFixedSafe(edgeData.length, 0);
            const TT = toFixedSafe(edgeData.TT, 2);
            const fft = toFixedSafe(edgeData.fft, 2);
            const AADT = toFixedSafe(volume / 0.18, 0);

            return `
                <div class="edge-popup">
                    <h3>Edge Details</h3>
                    <p><strong>From:</strong> <span class="coordinate">&nbsp;&nbsp;${from}</span></p>
                    <p><strong>To:</strong> <span class="coordinate">&nbsp;&nbsp;${to}</span></p>
                    <p><strong>Highway:</strong>&nbsp;&nbsp; ${highway}</p>
                    <p><strong>AADT:</strong> <span class="volume-tt">&nbsp;&nbsp; ${AADT}</p>
                    <p><strong>Capacity:</strong>&nbsp;&nbsp; ${capacity} veh/hr</p>
                    <p><strong>Length:</strong>&nbsp;&nbsp; ${length} meters</p>
                    <p><strong>Travel Time:</strong> <span class="volume-tt">&nbsp;&nbsp; ${TT} min</p>
                    <p><strong>Free Flow Time:</strong>&nbsp;&nbsp; ${fft} min</p>
                </div>
            `;
        }
        map.on('click', 'edges-layer', function (e) {
            if (e.features.length > 0) {
                const feature = e.features[0];
                const edgeData = feature.properties;
                const coordinates = feature.geometry.coordinates;
                const efrom = edgeData.from;
                const eto = edgeData.to;
                if (currentPopup) {
                    currentPopup.remove();
                }

                let reverseEdgeData = getReverseEdgeData(efrom, eto, e);
                const reverseEdgeExists = reverseEdgeData !== null;
                let isReverseEdgeShown = false;

                let popupContent = createPopupContent(edgeData);

                if (reverseEdgeExists) {
                    popupContent += `<button id="other-direction-btn">Other Direction</button>`;
                }
                currentPopup = new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(popupContent)
                    .addTo(map);
                if (reverseEdgeExists) {
                    document.getElementById('other-direction-btn').addEventListener('click', function() {
                        if (!isReverseEdgeShown) {
                            updatePopupContent(reverseEdgeData);
                            isReverseEdgeShown = true;
                        } else {
                            updatePopupContent(edgeData);
                            isReverseEdgeShown = false;
                        }
                    });
                }
            }
        });

        function updatePopupContent(edgeData) {
            const newPopupContent = createPopupContent(edgeData);

            if (currentPopup) {
                currentPopup.setHTML(newPopupContent);
            }
        }
        map.on('mouseenter', 'edges-layer', function () {
            map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'edges-layer', function () {
            map.getCanvas().style.cursor = '';
        });
    }

    async function loadAndProcessData(folderPath, foldername, dataType) {
        if (dataType === 'congestion') {
            const linkinfo = await fetch(`${basepath}/${folderPath}/models/assignments/${foldername}/linkTT.csv`);
            const text = await linkinfo.text();
            const data = d3.csvParse(text);
            netinfo = await fetch(`${basepath}/${folderPath}/net.csv`);
            nettext = await netinfo.text();
            netdata = d3.csvParse(nettext);

            data.forEach((entry, index) => {
                const netentry = netdata.find(netentry => netentry.from === entry.from && netentry.to === entry.to);
                const TT = entry.TT || entry['EstimatedTT'];
                if (entry && netentry && TT !== null && netentry['Free Flow Time (min)'] !== null) {
                    entry.value = netentry['Free Flow Time (min)'] !== 0 ? (TT - netentry['Free Flow Time (min)']) / netentry['Free Flow Time (min)'] : 0;
                    entry.fft = netentry['Free Flow Time (min)'];
                } else {
                    entry.value = 0;
                    entry.fft = 0;
                }
            });
            const geojsonResponse = await fetch(`${basepath}/${folderPath}/edges.geojson`);
            const geojsonData = await geojsonResponse.json();
            geojsonData.features.forEach((feature, index) => {
                const entry = data[index];
                if (entry && entry.value !== null) {
                    feature.properties.value = entry.value;
                    feature.properties.volume = entry.Volume || entry.volume;
                    feature.properties.TT = entry.TT || entry['EstimatedTT'];
                    feature.properties.fft = entry.fft;
                } else {
                    feature.properties.value = 0;
                    feature.properties.volume = 0;
                    feature.properties.TT = 0;
                    feature.properties.fft = 0;
                }
            });
            return geojsonData;
        }
        else {
            const zoneinfo = await fetch(`${basepath}/${folderPath}/models/assignments/${foldername}/zone_outputs.csv`);
            const text = await zoneinfo.text();
            const data = d3.csvParse(text);
            const geojsonResponse = await fetch(`${basepath}/${folderPath}/zones.geojson`);
            const geojsonData = await geojsonResponse.json();
            geojsonData.features.forEach((feature, index) => {
                const entry = data[index];
                let area = toFixedSafe(calculateArea(feature.geometry),2);
                feature.properties.area = area;
                if (dataType === 'emission') {
                    if (entry && entry['carbon'] !== null) {
                        const carbon = parseFloat(entry['carbon']) > 0 ? parseFloat(entry['carbon']) : 0;
                        feature.properties.value = carbon / area;
                    } else {
                        feature.properties.value = 0;
                    }
                    feature.properties.zoneout = 'emission';
                }

                else if (dataType === 'equity') {
                    if (entry && entry['CI'] !== null) {
                        feature.properties.value = parseFloat(entry['CI']) > 0 ? parseFloat(entry['CI']) : 0;
                    } else {
                        feature.properties.value = 0;
                    }
                    feature.properties.zoneout = 'equity';
                }
            });
            return geojsonData;
        }
    }

    function removeBaseLayer() {
        // change visibilty to none only when gridPolygonLayerId, edgesLayerId layers are visible
        if (map.getLayer(gridPolygonLayerId) && map.getLayer(edgesLayerId)) {
            map.setLayoutProperty(gridPolygonLayerId, 'visibility', 'none');
            map.setLayoutProperty(gridPolygonLayerId + '-border', 'visibility', 'none');
            map.setLayoutProperty(edgesLayerId, 'visibility', 'none');
        }
    }
    </script>
    </body>
</html>
