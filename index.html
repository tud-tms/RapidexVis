<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COSMO Rapidex-Vis</title>
    <!-- Include Mapbox CSS -->
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.0.0-rc.1/mapbox-gl.css' rel='stylesheet' />
    <link href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.css' rel='stylesheet' />
    <!-- Include your custom CSS styles here -->
    <style>
body {
    background-color: #f1f1f1;
    font-family: 'San Francisco', Arial, sans-serif;
    font-weight: 400; /* This sets the font weight to Regular. Change this value to use other weights */
}

/* Container for the map and the overlays */
.map-container {
    position: absolute;
    bottom: 50px;
    left: 10px;
    z-index: 1000;
    display: flex;
    align-items: center;
    margin-right: 50px;
}

/* Styles for the map itself */
.map {
  height: 99%;
  width: 99%;
}

.radiobox-container{
    display: flex;
    gap: 40px;
    border-radius: 8px;
    padding: 5px;
    pointer-events: auto;
      border-radius: 8px;
  border-color: 2px solid #4CAF50;
  background-color: rgba(255, 255, 255, 0.5);
}
.roads {
  position: fixed;
  gap: 10px;
  border-radius: 8px;
  padding: 5px;
  pointer-events: auto;
  display: flex;
  right: 80px;
  bottom: 50px;
  border-radius: 8px;
  border-color: 2px solid #4CAF50;
  background-color: rgba(255, 255, 255, 0.5);
  flex-direction: column;
  align-items: flex-start;
}
        .road-container-row {
            display: flex; /* Align road containers in a row */
            flex-wrap: wrap; /* Wrap them to next line if space is not sufficient */
            margin-top: 5px; /* Spacing between label and road container row */
        }
        .road-container {
            text-align: center; /* Center-align the image and name */
            margin-right: 10px; /* Spacing between road containers */
        }

    .road-img {
        width: 50px;
        margin-right: 10px;
        cursor: pointer;
        transition: transform 0.3s ease;
        opacity: 1;
        margin-bottom: 4px;
    }
   .road-name {
            display: block;
            color: black;
            margin: 0; 
            white-space: pre-line;
    }
    .selected {
        position: relative;
        opacity: 0.5;
        transform: scale(0.8); 
    }

    .selected {
        opacity: 0.5;
        transform: scale(0.8);
    }


    .selected-text {
        color: red;
    }

    .button-container button {
        position: relative;
        border: none; 
        background: none; 
        padding: 0; 
        cursor: pointer;
    }
    .button-img { 
        width: 100px; 
        height: auto; 
        transition: transform 0.3s ease; 
    }
    .normal { 
        opacity: 0.5;
    }
    .highlighted { 
        opacity: 1;
        transform: scale(1.2); 
    }


.mapboxgl-ctrl-bottom-right {
    bottom: 30px !important;
}

.mapboxgl-ctrl-rotate {
    background-image: url('src/images/rotate.svg');
    background-size: 20px 20px;
    background-position: center;
    background-repeat: no-repeat;
    width: 32px;
    height: 32px;
}
.mapboxgl-ctrl-map {
    background-image: url('src/images/map.svg');
    background-size: 20px 20px;
    background-position: center;
    background-repeat: no-repeat;
    width: 32px;
    height: 32px;
}
.mapboxgl-ctrl-3d {
    background-image: url('src/images/3d.svg');
    background-size: 20px 20px;
    background-position: center;
    background-repeat: no-repeat;
    width: 32px;
    height: 32px;
}

#folderSlider {
    width: 100%;
    height: 20px; /* match the height of the SVG's rounded rectangle */
    border-radius: 4px;
    background: linear-gradient(to right, #ccc 0%, #ccc 100%);
    opacity: 0.8;
    appearance: none;  /* removes default styling */
    outline: none;
    transition: background 0.2s;
}

#folderSlider::-webkit-slider-thumb {
    width: 100px;
    height: 40px;  /* match the height of the SVG's rounded rectangle */
    background-image: url('src/images/slider.svg'); 
    background-size: cover;
    background-position: center;  /* vertically center the SVG within the thumb */
    cursor: grab;
    color: transparent;
    appearance: none;  /* removes default styling */
}

#folderSlider::-moz-range-thumb {
    width: 100px;
    height: 40px;  /* match the height of the SVG's rounded rectangle */
    background-image: url('src/images/slider.svg'); 
    color: transparent;
    background-size: cover;
    background-position: center;  /* vertically center the SVG within the thumb */
    cursor: grab;
}

    #folderName {
        display: none;
        position: absolute;
        top: -38px;
        left: 0;
        background-color: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 5px 10px;
        border-radius: 5px;
        white-space: nowrap;
    }

    .mapboxgl-popup {
        /* This ensures the popup width is enough to prevent wrapping for typical content */
        min-width: 200px; 
    }

    .mapboxgl-popup-content {
        padding: 12px 15px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .mapboxgl-popup-close-button {
        position: absolute;
        right: 10px;
        top: 10px;
        width: 16px;
        height: 16px;
    }
    .edge-popup {
        width: 250px;
    }
    .edge-popup h3, .zone-popup h3 {
        margin-top: 0;
        color: #333;
        font-size: 15px;
        margin-bottom: 6px;
        padding-bottom: 3px;
        border-bottom: 1px solid #eee;
    }

    .edge-popup p, .zone-popup p {
        color: #555;
        margin: 4px 0;
        font-size: 14px;
        line-height: 1.4;
        display: flex;
    }

    .edge-popup p span {
        white-space: normal;
        display: inline-block;
        vertical-align: top;
    }
    #other-direction-btn {
        padding: 4px 10px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    .edge-popup .coordinate {
        margin-right: 4px;
        font-weight: bold;
        display: inline-block;
        min-width: 140px;
    }
    .zone-popup {
        width: 200px;
    }

    .zone-popup strong {
        font-weight: bold;
        margin-right: 4px;
    }
    .volume-tt {
        color: #4CAF50;
        font-weight: bold;
    }
    .co2 {
        color: #f44336;
        font-weight: bold;
    }
    #edge-options-container {
        display: none;
        position: absolute;
        background: white;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        font-family: Arial, sans-serif;
    }
    #edge-options-container label {
        display: block;
        margin-bottom: 8px;
    }
    #edge-options-container input, #edge-options-container select {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    #edge-options-container button {
        padding: 8px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    #edge-options-container button:hover {
        background-color: #0056b3;
    }

    .form-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 95%;
    }

    .form-column {
        display: flex;
        flex-direction: column;
        margin-bottom: 10px;
        width: 45%;
    }

    .form-column input[type="text"],
    .form-column input[type="number"],
    .form-column select {
        width: 100%;
    }

    .small-input {
        width: 10%;
    }

    .radio-group {
        display: flex;
        align-items: center;
    }

    .radio-label {
        margin-right: 10px;
    }

    .popup {
    display: none;
    position: absolute;
    width: 350px;
    height: 300px;
    bottom: 110%; /* Position above the button */
    transform: translateX(0%);
    border: 2px solid #4CAF50;
    border-radius: 8px;
    background-color: #fff;
    padding: 10px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 10;
}

.popup-heading {
    font-weight: bold;
    margin: 0;
    padding: 0;
    text-align: center;
}

.popup-text {
    margin: 10px 0 0; /* Adds some space above the text */
    color: #333;
    text-align: justify;
    font-size: large;
}

.close-btn {
    position: absolute;
    top: 0;
    right: 10px;
    cursor: pointer;
    font-size: 20px;
}

 </style>
<link rel="icon" href="src/images/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="src/images/favicon.ico" type="image/x-icon">
</head>
<body>
    <div id="map" style="width: 99vw; height: 98.5vh;"></div>
    <div class="map-container">
        <div class="radiobox-container" id="checkbox-dataDropdown">
            <div class="button-container">
                <button onclick="selectVisualization('congestion')">
                    <img id="congestionImg" class="button-img highlighted" src="src/images/congestion.png" alt="Congestion">
                    <div class="popup" id="congestionPopup">
                        <h1 class="popup-heading">Stau</h1>
                        <p class="popup-text">Die Karte veranschaulicht die Überlastung des Netzes anhand eines Farbverlaufs, der linear von grün über orange nach rot verläuft, wobei jede Verbindung farblich gekennzeichnet ist, um den Grad der Überlastung darzustellen.<br><br> Diese Links sind interaktiv; wenn Sie auf einen Link klicken, werden Informationen zum Verkehrsfluss, zur Kapazität, zur Reisezeit und zur Reisezeit im freien Verkehr angezeigt.</p>
                        <span class="close-btn" onclick="closePopup(event, 'congestionPopup')">&times;</span>
                    </div>
                </button>
            </div>
            <div class="button-container">
                <button onclick="selectVisualization('emission')">
                    <img id="emissionImg" class="button-img normal" src="src/images/emissions.png" alt="Zonal Emissions">
                    <div class="popup" id="emissionPopup">
                        <h1 class="popup-heading">Emissionen</h1>
                        <p class="popup-text">Die angezeigte Karte kategorisiert die zonalen Emissionen anhand eines linearen Farbverlaufs, der von Grün über Orange bis Rot reicht. <br><br> Die Zonen auf der Karte sind interaktiv. Wenn Sie eine Zone auswählen, erscheint ein Pop-up-Fenster mit Informationen über die zonalen Emissionen und ihre Fläche.</p>
                        <span class="close-btn" onclick="closePopup(event, 'emissionPopup')">&times;</span>
                    </div>
                </button>
            </div>
            <div class="button-container">
                <button onclick="selectVisualization('equity')">
                    <img id="equityImg" class="button-img normal" src="src/images/equity.png" alt="Zonal Equity">
                    <div class="popup" id="equityPopup">
                        <h1 class="popup-heading">Gerechtigkeit</h1>
                        <p class="popup-text">Die Karte zeigt die zonale Gerechtigkeit mit einem linearen Farbverlauf von Rot zu Orange und schließlich zu Grün. <br><br> Die Zonen auf der Karte sind interaktiv. Wenn Sie eine Zone auswählen, erscheint ein Popup-Fenster, das Informationen über die zonale Gerechtigkeit und ihr Gebiet enthält.</p>
                        <span class="close-btn" onclick="closePopup(event, 'equityPopup')">&times;</span>
                    </div>
                </button>
            </div>
        </div>
        <div class="roads" id="road-selection">
            <label><strong>Zu schließende Straße(n) auswählen</strong></label>
            <div class="road-container-row">
            <div class="road-container">
                <img src="src/images/bridge.png" alt="Carola Bridge" class="road-img" onclick="toggleSelection(this, 'road1')">
                <span class="road-name">Carolabrücke</span>
            </div>
            <div class="road-container">
                <img src="src/images/road.png" alt="Königsbrücker Straße" class="road-img" onclick="toggleSelection(this, 'road2')">
                <span class="road-name">Königsbrücker<br>Straße</span>
            </div>
            <div class="road-container">
                <img src="src/images/street.png" alt="Zellescher Weg" class="road-img" onclick="toggleSelection(this, 'road3')">
                <span class="road-name">Zellescher<br> Weg</span>
            </div>
            <div class="road-container">
                <img src="src/images/highway.png" alt="Road 4" class="road-img" onclick="toggleSelection(this, 'road4')">
                <span class="road-name">Bautzner<br>Straße</span>
            </div>
            </div>
        </div>
    </div>
    <div id="folderSliderContainer" style="position: fixed; bottom: 10px; left: 1vw; z-index: 1000; width: 98vw;">
        <div id="folderName"></div>
        <input type="range" min="0" max="0" value="0" class="slider" id="folderSlider">
    </div>
    </div>
    </div>

    <script src='https://api.mapbox.com/mapbox-gl-js/v3.0.0-rc.1/mapbox-gl.js'></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf"></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.4.3/mapbox-gl-draw.js'></script>
<script>
            let edgesLayerId = null;
        let gridPolygonLayerId = null;
        let basepath = '/src/data/Dresden/';
        let folder = null;
        let dataType = null;
        let directories = null;
        let bounds = null;
        let breaks = null;
        let currentPopup = null;

        let popupTimer;

        function selectVisualization(visualization) {
            // Close any previously opened popup
            closeCurrentPopup();

            // Reset all to normal
            document.querySelectorAll('.button-img').forEach(img => {
                img.classList.remove('highlighted');
                img.classList.add('normal');
            });

            // Highlight selected
            const imgId = visualization + 'Img';
            const popupId = visualization + 'Popup';
            const selectedImg = document.getElementById(imgId);
            if (selectedImg) {
                selectedImg.classList.remove('normal');
                selectedImg.classList.add('highlighted');
                // Show the popup
                const popup = document.getElementById(popupId);
                popup.style.display = 'block';
                // Set a timer to automatically close the popup after 10 seconds
                popupTimer = setTimeout(() => {
                    popup.style.display = 'none';
                }, 30000);
            }
        }

        function closePopup(event, popupId) {
            // Prevent the click event from propagating to the parent elements
            event.stopPropagation();

            const popup = document.getElementById(popupId);
            popup.style.display = 'none';

            // Clear the timer when the popup is manually closed
            clearTimeout(popupTimer);
        }


        function closeCurrentPopup() {
            // Close the currently displayed popup if any
            const openPopup = document.querySelector('.popup[style*="display: block"]');
            if (openPopup) {
                openPopup.style.display = 'none';
            }
            // Clear any existing timer
            clearTimeout(popupTimer);
        }

        const selectedRoads = {};

        function toggleSelection(image, roadId) {
            // Toggle selection
            image.classList.toggle('selected');

            const roadNameSpan = image.nextElementSibling;
            roadNameSpan.classList.toggle('selected-text');
            
            // Update selected roads
            if (selectedRoads[roadId]) {
                delete selectedRoads[roadId];
            } else {
                selectedRoads[roadId] = true;
            }
        }



    // Define a counter variable to ensure unique layer IDs
    let layerCounter = 0;
    
    switch (Object.keys(selectedRoads).length) {
        case 1:
            folder = Object.keys(selectedRoads)[0];
            break;
        case 2:
            folder = Object.keys(selectedRoads).sort().join('_');
            break;
        case 3:
            folder = Object.keys(selectedRoads).sort().join('_');
            break;
        case 4:
            folder = Object.keys(selectedRoads).sort().join('_');
            break;
        default:
            folder = 'all-roads';
            break;
    }

    function updateVisPathAndVisualize(index) {
        sfolder = directories[index].name;
        colorCode(dataType, folder, sfolder);
        drawGeoJSONLayers(folder);
    }
    dataType = document.querySelector('.highlighted').alt;

    function drawGeoJSONLayers(folderPath) {
        // Remove existing layers
        if (edgesLayerId && map.getLayer(edgesLayerId)) {
            map.removeLayer(edgesLayerId);
            map.removeSource('edges-source');
        }
        if (gridPolygonLayerId && map.getLayer(gridPolygonLayerId + '-border')) {
            map.removeLayer(gridPolygonLayerId + '-border');
        }
        if (gridPolygonLayerId && map.getLayer(gridPolygonLayerId)) {
            map.removeLayer(gridPolygonLayerId);
            map.removeSource('grid-polygon-source');
        }
        // Get the colors based on the current style
        let edgeColor = '#8B008B';
        let zoneColor = '#4169E1';
        let zoneBorderColor = '#00008B';
        fetch(`${basepath}/${folderPath}/edges.geojson`)
            .then(response => response.json())
            .then(data => {
                edgesGeojsonData = data;
                map.addSource('edges-source', {
                    type: 'geojson',
                    data: edgesGeojsonData
                });
                edgesLayerId = 'edges-layer-' + new Date().getTime();

                map.addLayer({
                    id: edgesLayerId,
                    type: 'line',
                    source: 'edges-source',
                    paint: {
                        'line-color': edgeColor,
                        'line-width': [
                                    'interpolate', 
                                    ['linear'], 
                                    ['zoom'],
                                    // Zoom level and corresponding line width
                                    1, 1,  // At zoom level 1, line width will be 1
                                    5, 2,  // At zoom level 5, line width will be 2
                                    10, 3,  // At zoom level 10, line width will be 3
                                    15, 5,  // At zoom level 15, line width will be 4
                                    18, 10, // At zoom level 18, line width will be 10
                                    20, 15, // At zoom level 20, line width will be 15
                                ],
                    },
                });
            })
            .catch(error => console.error('Error fetching GeoJSON:', error));

        // Add grid_polygon.geojson layer
        map.addSource('grid-polygon-source', {
            type: 'geojson',
            data: `${basepath}/${folder}/aggrid_polygon.geojson`,
        });
        
        // Generate a unique layer ID using the counter
        gridPolygonLayerId = `grid-polygon-layer-${layerCounter}`;
        layerCounter++;

        // Add the grid polygon layer outside of the event handler
        map.addLayer({
            id: gridPolygonLayerId,
            type: 'fill',
            source: 'grid-polygon-source',
            paint: {
                'fill-color': zoneColor,
                'fill-opacity': 0.2, // You can adjust the opacity as needed
            },
        });
        map.addLayer({
            id: gridPolygonLayerId + '-border',
            type: 'line',
            source: 'grid-polygon-source',
            layout: {},
            paint: {
                'line-color': zoneBorderColor,
                'line-width': 3 // Adjust this value for your desired thickness
            }
        }, gridPolygonLayerId); // This ensures the line layer is below the fill layer

        // Fetch GeoJSON data to calculate bounds
        fetch(`${basepath}/${folderPath}/aggrid_polygon.geojson`)
            .then(response => response.json())
            .then(geojsonData => {
                // Extract coordinates from the GeoJSON data
                const coordinates = [];
                geojsonData.features.forEach(feature => {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates.forEach(polygon => {
                            polygon.forEach(coord => {
                                coordinates.push(coord);
                            });
                        });
                    }
                });

                // Calculate bounds from the coordinates
                bounds = coordinates.reduce(function (bounds, coord) {
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

                // Fit the map to the calculated bounds
                map.fitBounds(bounds, { padding: 20 }); // You can adjust the padding as needed
            });
    }

    // Initialize Mapbox
    mapboxgl.accessToken = 'pk.eyJ1Ijoic3VyZW5kcmEyOSIsImEiOiJjbHR3eGZ1bXIwMGFnMmpzMWVmZzMzc2YzIn0.zJApAGxS7gq9GUM4crBwWA';
    const map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/standard',
        center: [13.728688, 51.030713],
        zoom: 17,
        pitch: 60,
        bearing: 37.6,
        projection: 'globe' // set the projection to globe
    });
    map.addControl(new mapboxgl.NavigationControl(), 'bottom-right');
    // Create a new mapboxgl button control Top Down View and fit to map bounds
    class TopDown {
    onAdd(map) {
        this.map = map;
        this.container = document.createElement('div');
        this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
        const button = document.createElement('button');
        button.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-map';
        button.type = 'button';
        button.title = 'Top Down';
        button.onclick = () => {
            map.flyTo({
                    pitch: 0,
                    bearing: 0,
                });
            map.once('moveend', () => {
                map.fitBounds(bounds, {padding: 20});
            });
        };
        this.container.appendChild(button);
        return this.container;
    }

    onRemove() {
        this.container.parentNode.removeChild(this.container);
        this.map = undefined;
    }
}


    // Add the home button control to the map
    map.addControl(new TopDown(), 'bottom-right');

    // Create a new mapboxgl button control for 3D buildings
    class ThreeD {
        onAdd(map) {
            this.map = map;
            this.container = document.createElement('div');
            this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
            const button = document.createElement('button');
            button.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-3d';
            button.type = 'button';
            button.title = '3D View';
            button.onclick = () => {
                map.flyTo({
                    zoom: 16,
                    pitch: 65,
                    bearing: 0,
                });
            };
            this.container.appendChild(button);
            return this.container;
        }
    
        onRemove() {
            this.container.parentNode.removeChild(this.container);
            this.map = undefined;
        }
    }

    // Add the home button control to the map
    map.addControl(new ThreeD(), 'bottom-right');

    // Create a new mapboxgl button control for continuous rotation
    class RotateControl {
        onAdd(map) {
            this.map = map;
            this.container = document.createElement('div');
            this.container.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
            const button = document.createElement('button');
            button.className = 'mapboxgl-ctrl-icon mapboxgl-ctrl-rotate';
            button.type = 'button';
            button.title = 'Rotate';
            button.onclick = () => {
                this._rotateMap();
            };
            this.container.appendChild(button);
            return this.container;
        }

        _rotateMap() {
            const rotate = () => {
                this.map.setBearing(this.map.getBearing() + 0.25);
                this.animationFrame = requestAnimationFrame(rotate);
            };
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
                this.animationFrame = null;
            } else {
                this.animationFrame = requestAnimationFrame(rotate);
            }
        }

        onRemove() {
            if (this.animationFrame) {
                cancelAnimationFrame(this.animationFrame);
            }
            this.container.parentNode.removeChild(this.container);
            this.map = undefined;
        }
    }

    // Add the rotate button control to the map
    map.addControl(new RotateControl(), 'bottom-right');

    map.on('load', function() {
                // Add 3D building layer when zoom level is greater than 15
                map.addLayer({
                    'id': '3d-buildings',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 15,  // Specify the minimum zoom level for 3D buildings
                    'paint': {
                        'fill-extrusion-color': '#aaa',
                        'fill-extrusion-height': ['get', 'height'],
                        'fill-extrusion-base': ['get', 'min_height'],
                        'fill-extrusion-opacity': 0.6,
                    },
                });
            });


    function updateSliderBackgroundandOffset(slider, bubble) {
        const position = slider.value / slider.max;
        const offset = (slider.offsetWidth-bubble.offsetWidth) * position;
        bubble.style.left = `${offset}px`;
        const currentValuePercentage = position * 100;
        slider.style.background = `linear-gradient(to right, #4CAF50 ${currentValuePercentage}%, #ccc ${currentValuePercentage}%)`;
    }
        let slider = document.getElementById('folderSlider');
        let bubble = document.getElementById('folderName');

        slider.addEventListener('input', function() {
            let currentIndex = Number(slider.value);
            bubble.textContent = directories[currentIndex].name;
            updateVisPathAndVisualize(currentIndex);
        });
        slider.oninput = function() {
            updateSliderBackgroundandOffset(slider, bubble);
        }

        slider.onmousedown = function() {
            bubble.textContent = directories[Number(slider.value)].name;
            bubble.style.display = 'block';
        }
        
        slider.onmouseup = function() {
            bubble.style.display = 'none';
        }
    async function colorCode(dataType, folderPath, foldername) {
        switch (dataType) {
            case 'congestion':
                await updateEdgesLayer(folderPath, foldername, 'congestion', true);
                removeBaseLayer();
                break;
            case 'emissions':
                if (breaks === null) {
                    breaks = await getQuantiles();
                }
                await updateZonesLayer(folderPath, foldername, 'emissions');
                removeBaseLayer();
                break;
            case 'equity':
                if (breaks === null) {
                    breaks = await getQuantiles();
                }
                await updateZonesLayer(folderPath, foldername, 'equity');
                removeBaseLayer();
                break;
            default:
                break;
        }
    }

    async function getQuantiles() {
        const fullpath = `${folderPathFromSession}/${folderPath}/models/${visfolder}/${aepath}/`;
        const response = await fetch(`/get-quantiles?path=${encodeURIComponent(fullpath)}`);

        const result = await response.json();
        return result.breaks;
    }
    function toFixedSafe(value, digits) {
                        const number = parseFloat(value);
                        return !isNaN(number) ? number.toFixed(digits) : value;
                    }
    async function updateZonesLayer(folderPath, foldername, dataType) {
        const geojsonData = await loadAndProcessData(folderPath, foldername, dataType, false);
        // define color stops as an expression
        if (dataType === 'emissions') {
            const colorStops = [
                { value: breaks[0], color: 'green' },
                { value: breaks[1], color: 'orange' },
                { value: breaks[2], color: 'red' }
            ];
        }
        else if (dataType === 'equity') {
            const colorStops = [
                { value: breaks[0], color: 'red' },
                { value: breaks[1], color: 'orange' },
                { value: breaks[2], color: 'green' }
            ];
        }
        // define color stops as an expression
        const colorStopsExpression = colorStops.flatMap(stop => [stop.value, stop.color]);

        if (currentPopup) {
            currentPopup.remove();
            currentPopup = null;
        }
        // Ensure edges-layer is invisible when displaying zones
        if (map.getLayer('edges-layer')) {
            map.setLayoutProperty('edges-layer', 'visibility', 'none');
        }
        if (map.getLayer('zones-layer')) {
            map.getSource('zones-layer').setData(geojsonData);
            map.setLayoutProperty('zones-layer', 'visibility', 'visible');
        }
        else{
            map.addLayer({
                id: 'zones-layer',
                type: 'fill',
                source: {
                    type: 'geojson',
                    data: geojsonData,
                },
                paint: {
                    'fill-color': [
                        'case',
                        ['boolean', ['feature-state', 'hover'], false],
                        'blue',
                        // Use Mapbox GL JS expressions to define the color scale
                        ['interpolate', ['linear'], ['get', 'value'], ...colorStopsExpression],
                    ],
                    'fill-opacity': 0.4, // You can adjust the opacity as needed
                },
            });
        }
        // Add click event listener to the zones-layer
        map.on('click', 'zones-layer', function (e) {
            if (e.features.length > 0) {
                const feature = e.features[0];
                const zoneId = feature.properties.fishnetid || feature.properties.fishnetID; // Assuming the zone ID is stored in the property 'zone_id'
                const value = toFixedSafe(feature.properties.value/1000000, 3); // Assuming the value is stored in the property 'value'

                // Calculate the area using the geometry (requires a function to calculate the area)
                const area = toFixedSafe(calculateArea(feature.geometry),2); // This is a placeholder function
                if (currentPopup) {
                    currentPopup.remove();
                }
                // Create HTML content for the popup
                const popupContent = `
                    <div class="zone-popup">
                        <h3>Zone Details</h3>
                        <p><strong>Zone ID:</strong>&nbsp;&nbsp; ${zoneId}</p>
                        <p><strong>Area:</strong>&nbsp;&nbsp; ${area} km<sup>2</sup></p>
                        <p><strong>Value:</strong> <span class="co2">&nbsp;&nbsp;${value} Tons CO<sub>2</sub>/km<sup>2</sup> </span></p>
                        <p style="display: none;"><strong>Equity:</strong>&nbsp;&nbsp; ${feature.properties.equity}</p>
                    </div>
                `;

                currentPopup = new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(popupContent)
                    .addTo(map);
            }
        });
        map.on('mouseenter', 'zones-layer', function () {
            map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'zones-layer', function () {
            map.getCanvas().style.cursor = '';
        });
    }
    function calculateArea(geometry) {
        // Check if the geometry type is 'Polygon' or 'MultiPolygon'
        if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
            try {
                // Calculate the area using turf.area() which returns the area in square meters
                const area = turf.area(geometry);
                return area/1000000; // Return the area in square kilometers
            } catch (error) {
                console.error('Error calculating area:', error);
                return 0; // Return 0 if there was an error during calculation
            }
        } else {
            console.error('Invalid geometry type for area calculation.');
            return 0; // Return 0 if the geometry type is not suitable for area calculation
        }
    }
    async function updateEdgesLayer(folderPath, foldername, dataType, normalize) {
        const geojsonData = await loadAndProcessData(folderPath, foldername, dataType, normalize);
        // define color stops as an expression
        const colorStops = [
                    { value: 0.5, color: 'green' },
                    { value: 0.75, color: 'orange' },
                    { value: 10, color: 'red' }
                    ];

        const colorStopsExpression = colorStops.flatMap(stop => [stop.value, stop.color]);
        if (currentPopup) {
            currentPopup.remove();
            currentPopup = null;
        }
        // Ensure zones-layer is invisible when displaying edges
        if (map.getLayer('zones-layer')) {
            map.setLayoutProperty('zones-layer', 'visibility', 'none');
        }
        if (map.getLayer('edges-layer')) {
            map.getSource('edges-layer').setData(geojsonData);
            map.setLayoutProperty('edges-layer', 'visibility', 'visible');
        }
        else{
            map.addLayer({
                id: 'edges-layer',
                type: 'line',
                source: {
                    type: 'geojson',
                    data: geojsonData,
                },
                paint: {
                    'line-color': [
                        'case',
                        ['boolean', ['feature-state', 'hover'], false],
                        'red',
                        ['interpolate', ['linear'], ['get', 'value'], ...colorStopsExpression],
                    ],
                    'line-width': [
                        'interpolate',
                        ['linear'],
                        ['zoom'],
                        1, 1,
                        5, 2,
                        10, 3,
                        15, 5,
                        18, 10,
                        20, 15,
                    ],
                },
            });
        }
        // Function to check if reverse edge exists and get its data
        function getReverseEdgeData(efrom, eto, e) {
            for (let feature of e.features) {
                const edgeFrom = feature.properties.from;
                const edgeTo = feature.properties.to;
                // Check if this edge is the reverse of the one we're looking for
                if (edgeFrom === eto && edgeTo === efrom) {
                    return feature.properties; // Return the reverse edge data
                }
            }
            return null; // No reverse edge found
        }
        function createPopupContent(edgeData) {
            const from = edgeData.from;
            const to = edgeData.to;
            const highway = edgeData.highway;
            const volume = toFixedSafe(edgeData.volume, 0);
            const capacity = edgeData.capacity;
            const length = toFixedSafe(edgeData.length, 0);
            const TT = toFixedSafe(edgeData.TT, 2);
            const fft = toFixedSafe(edgeData.fft, 2);
            const AADT = toFixedSafe(volume / 0.18, 0);

            return `
                <div class="edge-popup">
                    <h3>Edge Details</h3>
                    <p><strong>From:</strong> <span class="coordinate">&nbsp;&nbsp;${from}</span></p>
                    <p><strong>To:</strong> <span class="coordinate">&nbsp;&nbsp;${to}</span></p>
                    <p><strong>Highway:</strong>&nbsp;&nbsp; ${highway}</p>
                    <p><strong>AADT:</strong> <span class="volume-tt">&nbsp;&nbsp; ${AADT}</p>
                    <p><strong>Capacity:</strong>&nbsp;&nbsp; ${capacity} veh/hr</p>
                    <p><strong>Length:</strong>&nbsp;&nbsp; ${length} meters</p>
                    <p><strong>Travel Time:</strong> <span class="volume-tt">&nbsp;&nbsp; ${TT} min</p>
                    <p><strong>Free Flow Time:</strong>&nbsp;&nbsp; ${fft} min</p>
                </div>
            `;
        }
        map.on('click', 'edges-layer', function (e) {
            if (e.features.length > 0) {
                const feature = e.features[0];
                const edgeData = feature.properties;
                const coordinates = feature.geometry.coordinates;
                const efrom = edgeData.from;
                const eto = edgeData.to;
                if (currentPopup) {
                    currentPopup.remove();
                }

                // Check if the reverse edge exists
                let reverseEdgeData = getReverseEdgeData(efrom, eto, e);
                const reverseEdgeExists = reverseEdgeData !== null;
                let isReverseEdgeShown = false;

                let popupContent = createPopupContent(edgeData);

                // Add "Other Direction" button if reverse edge exists
                if (reverseEdgeExists) {
                    popupContent += `<button id="other-direction-btn">Other Direction</button>`;
                }
                
                // <p><strong>From and To Nodes:</strong> ${edgeData.from},\n${edgeData.to}</p>
                currentPopup = new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(popupContent)
                    .addTo(map);
                // Add click event listener for the "Other Direction" button
                if (reverseEdgeExists) {
                    document.getElementById('other-direction-btn').addEventListener('click', function() {
                        // Logic to toggle between original and reverse edge data
                        if (!isReverseEdgeShown) {
                            updatePopupContent(reverseEdgeData);
                            isReverseEdgeShown = true;
                        } else {
                            updatePopupContent(edgeData);
                            isReverseEdgeShown = false;
                        }
                    });
                }
            }
        });

        function updatePopupContent(edgeData) {
            const newPopupContent = createPopupContent(edgeData);

            if (currentPopup) {
                currentPopup.setHTML(newPopupContent);
            }
        }
        map.on('mouseenter', 'edges-layer', function () {
            map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'edges-layer', function () {
            map.getCanvas().style.cursor = '';
        });
    }

    async function loadAndProcessData(folderPath, foldername, dataType, normalize) {
        if (dataType === 'congestion') {
            const linkinfo = await fetch(`${basepath}/${folderPath}/${foldername}/link.csv`);
            const text = await linkinfo.text();
            const data = d3.csvParse(text);
            netinfo = await fetch(`${basepath}/${folderPath}/net.csv`);
            nettext = await netinfo.text();
            netdata = d3.csvParse(nettext);

            data.forEach((entry, index) => {
                // get netentry based on the from and to nodes matching entry from and to nodes
                const netentry = netdata.find(netentry => netentry.from === entry.from && netentry.to === entry.to);
                // const netentry = netdata[index];
                const TT = entry.TT || entry['EstimatedTT']; // Handle both cases
                if (entry && netentry && TT !== null && netentry['Free Flow Time (min)'] !== null) {
                    entry.value = netentry['Free Flow Time (min)'] !== 0 ? (TT - netentry['Free Flow Time (min)']) / netentry['Free Flow Time (min)'] : 0;
                    entry.fft = netentry['Free Flow Time (min)'];
                } else {
                    entry.value = 0;
                    entry.fft = 0;
                }
            });
            const geojsonResponse = await fetch(`${basepath}/${folderPath}/edges.geojson`);
            const geojsonData = await geojsonResponse.json();
            geojsonData.features.forEach((feature, index) => {
                const entry = data[index];
                if (entry && entry.value !== null) {
                    feature.properties.value = entry.value;
                    feature.properties.volume = entry.Volume || entry.volume; // Handle both cases
                    feature.properties.TT = entry.TT || entry['EstimatedTT']; // Handle both cases
                    feature.properties.fft = entry.fft;
                } else {
                    feature.properties.value = 0;
                    feature.properties.volume = 0;
                    feature.properties.TT = 0;
                    feature.properties.fft = 0;
                }
            });
            return geojsonData;
        } else if (dataType === 'emissions') {
            const zoneinfo = await fetch(`${basepath}/${folderPath}/${foldername}/zone_emissions.csv`);
            const text = await zoneinfo.text();
            const data = d3.csvParse(text);
            const geojsonResponse = await fetch(`${basepath}/${folderPath}/aggrid_polygon.geojson`);
            const geojsonData = await geojsonResponse.json();
            geojsonData.features.forEach((feature, index) => {
                const entry = data[index];
                if (entry && entry['CO2psqkm'] !== null) {
                    feature.properties.value = parseFloat(entry['CO2psqkm']) > 0 ? parseFloat(entry['CO2psqkm']) : 0;
                } else {
                    feature.properties.value = 0;
                }
            });
            return geojsonData;
        }
        else {
            const zoneinfo = await fetch(`${basepath}/${folderPath}/${foldername}/zone_equity.csv`);
            const text = await zoneinfo.text();
            const data = d3.csvParse(text);
            const geojsonResponse = await fetch(`${basepath}/${folderPath}/aggrid_polygon.geojson`);
            const geojsonData = await geojsonResponse.json();
            geojsonData.features.forEach((feature, index) => {
                const entry = data[index];
                if (entry && entry['Equity'] !== null) {
                    feature.properties.value = parseFloat(entry['Equity']) > 0 ? parseFloat(entry['Equity']) : 0;
                } else {
                    feature.properties.value = 0;
                }
            });
            return geojsonData;
        }
    }

    function removeBaseLayer() {
        // change visibilty to none only when gridPolygonLayerId, edgesLayerId layers are visible
        if (map.getLayer(gridPolygonLayerId) && map.getLayer(edgesLayerId)) {
            map.setLayoutProperty(gridPolygonLayerId, 'visibility', 'none');
            map.setLayoutProperty(gridPolygonLayerId + '-border', 'visibility', 'none');
            map.setLayoutProperty(edgesLayerId, 'visibility', 'none');
        }
    }
    </script>
    </body>
</html>
